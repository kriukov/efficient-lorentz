

# using EfficientLorentz; x = 0; y = 0.445; vx = cos(1); vy = sin(1); r = 0.1
# using EfficientLorentz; x = 0; y = 0.35; vx = cos(1); vy = sin(1); r = 0.1


#c = sqrt(1.001) # Irrationalizing coefficient
# Split the 1st quadrant into N = 30 equal angular parts
# For each n < N, slope is tg(pi n/(2N))

#N = 30

#=
for n = 1:N-1
	loops = 0
	for m = 1:N
		for b = 1:N
			x = eff(tan(pi*n/(2N))*c, b/N*c, n/N)
			if x == 3000
				loops += 1
				break
			end
		end
	end
	println(n/N, " ", loops/N^2)
end
=#

#=
for n = 1:N-1
	loops = 0
	@show n
	for m = 1:N
		for b = 1:N
			m = tan(pi*rand()/2)
			x = eff(m, rand(), n/N*sqrt(1 + m^2))
			if x == 300
				loops += 1
				break
			end
		end
	end
	println(n/N, " ", loops/N^2)
end
=#

# Testing

#=
r = 0.001
x = 0
y = 0.445
for deg = 1:89
	if deg != 45
		vx = cos(deg*pi/180)
		vy = sin(deg*pi/180)
		println(deg, " ", first_collision(x, y, vx, vy, r/vx))
	end
end
=#

# Measuring the times

#= This one still gives error due to ContinuedFractions limits. Trying to work around
function measuring()
for i = 1:100
	r = i/1000
	for j = 1:100
		for k = 1:100
			vx = j*sqrt(0.999)
			vy = k*sqrt(1.002)
			#println(i, " ", j, " ", k, " ", vy/vx)
			first_collision(0, 0.445, vx, vy, r/vx)
		end
	end
end
end

@time measuring()
=#

#=
x = 0
y = 0.445


function measuring()
for i = 1:100
	r = i/1000
	for deg = 1:89
		if deg != 45
			vx = cos(deg*pi/180)
			vy = sin(deg*pi/180)
			#println(r, " ", deg, " ", first_collision(x, y, vx, vy, r/vx))
			first_collision(x, y, vx, vy, r/vx)
		end
	end
end
end

@time measuring()
=#

# with println: 112.495258954 s
# without println: 109.723781459 s

# After changing the frac() function into Atahualpa's one

# with println: 62.02397 s
# without println: 20.11622 s
# deg 1-44: 11.938 s
# deg 46-89: 7.825 s

#=
function measuring2()
	r = 0.000001
	for deg = 46:89
		if deg != 45
			vx = cos(deg*pi/180)
			vy = sin(deg*pi/180)
			#println(r, " ", deg, " ", first_collision(x, y, vx, vy, r/vx))
			first_collision(x, y, vx, vy, r/vx)
		end
	end
end

@time measuring2()
=#

############ Tests for 3D version


# Testing: using EfficientLorentz; x = [0.2, 0.3, 0.2]; v = [cos(1), sin(1), sin(0.4)]; r = 0.1


Line that will cross [3, 4, 5] with r = 0.1:

using EfficientLorentz; x = [0, 0.445, 0.342]; v = [0.451207, 0.541449, 0.709398]; r = 0.1
collisions3d(x, v, r, 5)


x = [-2.125652728087777,-2.1057861003273635,-3.0]
v = [-0.4512069325775071,-0.5414489190929208,-0.7093978939968069]

x = [-37.06038678750248, -44.027513426667056, -57.92519059385232]; v = [0.4512069325775123, 0.5414489190929171, 0.7093978939968061]

2d version gives strange results too... Test:

using EfficientLorentz; x = [0.445, 0.342]; v = [0.60672, 0.794915]; r = 0.2
collisions(x[1], x[2], v[1], v[2], r, 3)

using EfficientLorentz; x = [0.0,0.445]; v = [0.640184,0.768222]; r = 0.2

Next test 3D

using EfficientLorentz; x = [-1.96460353861745473485,12.0000000000739345148,-19.089208334145857042]; v = [0.492197878294012166407,0.739345146123457909362,-0.459467086423560331943]; r = 0.2

This line really hits [0, 15, -21]

!!!!!!!!!!!!!!
Similar test with the start not from the inside of an obstacle:
using EfficientLorentz; x = [-1.81694, 12.2218, -19.227]; v = [0.492197878294012166407,0.739345146123457909362,-0.459467086423560331943]; r = 0.2
The algorithm gets stuck at xy, yz, xz = [0, 15], [15, -21], [-1, 20]

using EfficientLorentz; x = [-31.5646794874135777267, 10.0000000000071421636, -8.86136400925839916656]; v = [-0.995170604930726595226, 0.0714216332842911117977, 0.0673380826933461717346]; r = 0.2
collisions3d(x, v, r, 5)

###############

using EfficientLorentz; 

using ClassicalLorentz; x = [0, 0.445, 0.342]; v = [0.451207, 0.541449, 0.709398]; r = 0.2

collisions3d(x, v, r, 500)

Additional step at the end: 0.1
 BigInt[3,4,5]            
 BigInt[-5377,-1447,-1929]
 BigInt[-5386,-1453,-1927]
 BigInt[-5383,-1455,-1932]
 BigInt[-5432,-1490,-1909]
 BigInt[-5422,-1500,-1916]

Additional step at the end: 0.2
 BigInt[3,4,5]          
 BigInt[-709,-188,-251] 
 BigInt[-682,-320,-160] 
 BigInt[-685,-322,-158] 
 BigInt[-670,-310,-162] 
 BigInt[-759,-311,-187] 
 BigInt[-748,-287,-189] 
 BigInt[-739,-285,-189] 
 BigInt[-704,-286,-187] 
 BigInt[-634,-274,-230] 
 BigInt[-563,-246,-193] 
 BigInt[-580,-251,-214] 
 BigInt[-569,-233,-223] 
 BigInt[-468,-335,-167] 
 BigInt[-459,-326,-162] 


Additional step at the end: 0.5
 BigInt[3,4,5]          
 BigInt[-798,-212,-283] 
 BigInt[-798,-214,-282] 
 BigInt[-813,-182,-321] 
 BigInt[-768,-290,-320] 
 BigInt[-674,-254,-473] 
 BigInt[-307,-284,-529] 
 BigInt[-279,-323,-531] 
 BigInt[-280,-320,-528] 
 BigInt[-241,-341,-505] 
 BigInt[-139,-289,-486] 
 BigInt[-98,-311,-450]  
 BigInt[-57,-329,-428]  
 BigInt[-46,-300,-391]  
 BigInt[-95,-875,-623]  
 BigInt[-96,-877,-622]  
 BigInt[-135,-843,-640] 
 BigInt[-140,-857,-601] 
 BigInt[-287,-562,-163] 
 
No additional step
 BigInt[3,4,5]
 (none new even after 1000 iterations)
 
 
Probably this step is wrong


Testing again with r = 0.2, because 0.1 seems to fall in channels often

No step:
 BigInt[3,4,5]     
 BigInt[-14,-6,-8] 
 BigInt[-4,9,-17]  
 BigInt[-3,10,-20] 
 BigInt[-3,9,-19]  
 BigInt[-3,12,-18] 
 BigInt[-1,9,-19]  
 BigInt[-8,-11,47] 
 BigInt[-13,-15,44]
 BigInt[-20,-5,48] 
 BigInt[-26,-8,47] 
 BigInt[-20,-1,52] 
 BigInt[-19,-1,52] 
 BigInt[-19,-3,53] 
 BigInt[-20,-5,52] 

 
Step 0.1
 BigInt[3,4,5]      
 BigInt[-14,-6,-8]  
 BigInt[-4,9,-17]   
 BigInt[-3,10,-20]  
 BigInt[-2,11,-20]  
 BigInt[-3,10,-22]  
 BigInt[1,0,-11]    
 BigInt[0,-1,-17]   
 BigInt[-21,-17,-20]
 BigInt[-20,-14,-20]
 BigInt[-26,-12,-21]
 BigInt[6,-20,-101] 
 BigInt[5,-19,-102] 
 BigInt[-2,-20,-90] 
 BigInt[1,-20,-91]  
 BigInt[14,-2,-108] 

Step 0.3
 BigInt[3,4,5]       
 BigInt[-14,-6,-8]   
 BigInt[-4,9,-17]    
 BigInt[-3,10,-19]   
 BigInt[-32,7,-7]    
 BigInt[-27,16,-8]   
 BigInt[-28,16,-8]   
 BigInt[-69,18,-50]  
 BigInt[-74,12,-52]  
 BigInt[-74,12,-51]  
 BigInt[-73,21,-43]  
 BigInt[-78,15,-46]  
 BigInt[-77,18,-49]  
 BigInt[-79,15,-51]  
 BigInt[-70,16,-85]  
 BigInt[-71,12,-83]  
 BigInt[-77,6,-84]   
 BigInt[-81,5,-85]   
 BigInt[-85,4,-84]   
 BigInt[-84,3,-85]   
 BigInt[-79,11,-79]  

Maybe the variations are caused by chaoticity and not by this step?
Step is unnecessary

## ND tests
Example: N = 5

using EfficientLorentz; x = [0.213, 0.445, 0.331, 0.254, 0.188]; v = [0.347678, 0.541476, 0.233173, 0.414546, 0.599755]; N = 5; r = 0.1
collisionsnd(x, v, r, 5)


#################################################

# Tests of classical 2D Lorentz - moved from the module


#println(collisions([0.4, 0.1], [-0.42, 0.23], 0.3, 20)[1])

#println(collisions([0.4, 0.1], [0.5, 0.5], 0.3, 20)[1])
#collisions([0, 0.445], [cos(1), sin(1)], 0.1, 20)

# For testing Atahualpa's algorithm
#= with the function collisions()
for deg = 1:89
	if deg != 45
		phi = deg*pi/180
		v0 = [cos(phi), sin(phi)]
		println(deg, " ", collisions([0, 0.445], v0, 0.1, 100)[2][1])
	end
end
=#


#= with the function first_collision()
for deg = 1:89
	if deg != 45
		phi = deg*pi/180
		v0 = [cos(phi), sin(phi)]
		println(deg, " ", first_collision([0, 0.445], v0, 0.1, 100))
	end
end
=#

x = 0
y = 0.445

#=
function measuring()
for i = 1:100
	rho = i/1000
	for deg = 1:89
		if deg != 45
			vx = cos(deg*pi/180)
			vy = sin(deg*pi/180)
			#println(rho, " ", deg, " ", first_collision([x, y], [vx, vy], rho))
			first_collision([x, y], [vx, vy], rho)
		end
	end
end
end

@time measuring()
=#
# without println: 1.532468791 s

#=
function measuring2()
	rho = 0.000001
	for deg = 1:89
		if deg != 45
			vx = cos(deg*pi/180)
			vy = sin(deg*pi/180)
			col = first_collision([x, y], [vx, vy], rho)
			println(rho, " ", deg, " ", col)
			col
		end
	end
end

@time measuring2()
=#

####################################################################################


Classical (C) and Efficient (E) algorithms don't coincide after the first hit. It is possible that E misses balls. Need to see the WM simulation.

Start with usual parameters:

x = [0, 0.445, 0.342]; v = [0.451207, 0.541449, 0.709398]; r = 0.2

Coords and speed after the first hit (both C and E agree):

x = [2.88124933590079817603,3.90250303447010145775,4.87196632673995360611]; v = [-0.719660173353565737683,-0.419859303753652908205,-0.552998553289439927704]

Observation of the simulation:

In the xy-plane, the line crosses 1,3 and -2,1
yz: 3,4(???) and 1,3
xz: 2,4 , -1,2 and -2,1


x=1, y=3; x=-2, y=1
y=3(?), z=4(?); y=1, z=3
x=2, z=4; x=-1, z=2


(-2, 1, 1) really gets hit
C is correct, E misses it

#############

David Sanders' idea:

x = [0, 0, 0]; v = [1, 1, 0.5]

Need to "smudge" the values because frac() gets confused when they are too exact/integer/"nice".

x = [0.00001,-0.003, 0.002]; v = [1.002, 1.007, 0.49997]

Normalize velocity and advance from the origin along the trajectory to come out of the (0,0,0) ball of radius r = 0.2:

using EfficientLorentz; x = [0.532282, 0.531928, 0.267589]; v = [0.665341, 0.668661, 0.331986]; r = 0.2

The next collision (according to C) is (0,0,0), but E misses it.
Coords and speed after first collision:
x = [1.86388978276529009557,1.87018040234950435349,0.932022938941261145426]; v = [-0.695301102766206562253,-0.629096185054838065367,-0.347554839473637600025]; r = 0.2

With time corrections, it improved, but it misses again:
starting from place [-2,2,-1]:
x = [-2.02199478575371421668e+00,2.19282862284883599963e+00,-9.5169522166628252774e-01]; v = [-3.22442298116371155056e-01,8.17480386148925560798e-01,4.77238706149487402109e-01]

C says next is [-4,7,2]

E gives 
(x1,y1) = first(Pxy(x),v_xy,r) => BigInt[-3,5]
(y2,z2) = first(Pyz(x),v_yz,r) => BigInt[4,0]
(x3,z3) = first(Pxz(x),v_xz,r) => BigInt[-4,2]

but then proceeds and misses it. Maybe we advanced too far? Let's advance to the closest instead

Helps. But after place [17,22,5]:

x = [16.8289990492993435135, 22.0452392128352392103, 4.90666143090062079925]; v = [-0.388641823164963131992, -0.169475879050012219677, -0.905668515356054074767]; r = 0.2

C and E diverge. Found out: x is inside the ball! Need to advance a little further?

x = [16.8289992589530794861, 22.0452390937991342373, 4.9066609891115339926]; v = [-0.388637381921072624002,-0.169477505754780016331, -0.905670116773581549492]

collisions3d_classical(x, v, r, 10, 64)[2]
collisions3d(x, v, r, 5, 64)[1]

A little back from the problematic point: [10, 26, 7]
C: x = [7.91436647375016094413, 28.8416679287440336863, 4.08716567210670571938]; v = [0.482967544197343598883, -0.62829344671166042184, 0.609909580242160881999]
E: x = [7.91436489051200855538, 28.8416677450009912818, 4.08716378290269764144]; v = [0.482950923552208117104, -0.628308912921221623677, 0.609906808769849669732]

WM: so we do have a collision at [10, 26, 7]. C and E agree here. Proceed:

C: x = [10.0764053422964544949, 26.029067229247587742, 6.81746967415678619328]; v = [0.837062156955717057171, -0.493583634870910865824, -0.236013009769084225237]
E: x = [10.0763022243879987808, 26.029033106971180736, 6.81742111498575890103]; v = [0.836793467368476666293, -0.493671312143907367321, -0.236781182815600773207]

WM 3D plot: E is correct! C is wrong, because of the error when the collision point for some reason turns out to be (very slightly) inside a ball. So the place of collision is [12,20,-6], not [13,21,-2].


################

Find out what's wrong with C here

using ClassicalLorentz; x = [7.91436647375016094413, 28.8416679287440336863, 4.08716567210670571938]; v = [0.482967544197343598883, -0.62829344671166042184, 0.609909580242160881999]; r = 0.2

collisions3d_classical(x, v, r, 20, 64)[2]

From the start:

using ClassicalLorentz; x = [0.532282, 0.531928, 0.267589]; v = [0.665341, 0.668661, 0.331986]; r = 0.2

####################

When we change r from 0.2, the tests of comparison for 3D show worse results.
r = 0.15: only element 1 passed. Let's see. Here is what happens:

E:
([BigInt[2,2,1],
BigInt[-7,-7,-4]],

[BigFloat[1.89717182844582602939e+00,1.90362852285732340833e+00,9.48629721354036554277e-01],
BigFloat[-6.99408626553392691631e+00,-6.87166283497533916715e+00,-4.07742480105300724499e+00]],

[BigFloat[-7.04877071895435892979e-01,-6.15519586395728865533e-01,-3.52539291823404229151e-01],
BigFloat[-6.75509618960506844738e-01,2.17994672895895364324e-02,-7.37028858266568126284e-01]])

C:
[BigInt[2,2,1],
BigInt[-6,-5,-3]

BigFloat[1.89717182844582602798e+00,1.90362852285732340682e+00,9.48629721354036553572e-01],
BigFloat[-5.89738387549017934906e+00,-4.90280893172464143481e+00,-2.94976229266696604505e+00]],

BigFloat[-7.04877071895435891515e-01,-6.15519586395728866943e-01,-3.52539291823404228745e-01],
BigFloat[6.62111319435626230706e-01,6.79199569176793719162e-01,3.16696299165733739979e-01]],
BigFloat[0e+00,2.05141488547401285567e+00,1.31094504135359598085e+01])

WM: here C is correct and E is wrong! What's going on?!

###############

Test more. 


using EfficientLorentz; x = [-4.03108362719620705447, -2.90699675491303412365, -2.01960113577374986778]; v = [-8.79327751905091057835, -1.21256670037629447435, -4.60520927538504037778]/10; r = 0.1


Test with bigger balls for better visualization

using EfficientLorentz; x = [0.532282, 0.531928, 0.267589]; v = [0.665341, 0.668661, 0.331986]; r = 0.25
compare_lorentz3d(x, v, r, 100, 64)

Element 1 passed: BigInt[2,2,1]
Place: 
 efficient  BigFloat[1.8306137437808465509e+00,1.83673831851072543451e+00,9.15419153696868457453e-01], 
 classical  BigFloat[1.83061374378084654895e+00,1.83673831851072543266e+00,9.15419153696868456477e-01], 
 difference BigFloat[1.95156391047390798121e-18,1.84314369322535753781e-18,9.75781955236953990607e-19]
Speed: 
 efficient  BigFloat[-6.89456030301879826733e-01,-6.37150039390786929573e-01,-3.44514454826923089841e-01], 
 classical  BigFloat[-6.89456030301879826733e-01,-6.37150039390786929899e-01,-3.44514454826923089841e-01], 
 difference BigFloat[0e+00,3.25260651745651330202e-19,0e+00]
---------------------------
Element 2 passed: BigInt[0,0,0]
Place: 
 efficient  BigFloat[9.03873664987589181931e-02,2.28535248115236243262e-01,4.58450035044872204466e-02], 
 classical  BigFloat[9.03873664987589150489e-02,2.28535248115236239494e-01,4.58450035044872189152e-02], 
 difference BigFloat[3.14418630020796285862e-18,3.76760254938712790818e-18,1.53143556863577501304e-18]
Speed: 
 efficient  BigFloat[-4.23587770898546668598e-02,9.98969443297411327845e-01,-1.63029249373263497814e-02], 
 classical  BigFloat[-4.23587770898546786742e-02,9.98969443297411327574e-01,-1.63029249373263553091e-02], 
 difference BigFloat[1.18144155483029811293e-17,2.71050543121376108502e-19,5.52773701378156401276e-18]
---------------------------
Diverged at element 3 - increase precision
Classical: BigInt[0,1,0]; Efficient: BigInt[0,2,0]

Difference is still small, but after step 2 it diverges. Look in WM. (0,1,0) is hit. E missed y = 1. Why?!!

using EfficientLorentz; x = [9.03873664987589181931e-02,2.28535248115236243262e-01,4.58450035044872204466e-02]; v = [-4.23587770898546668598e-02,9.98969443297411327845e-01,-1.63029249373263497814e-02]; r = 0.25
collisions3d(x, v, r, 1, 64)

Modified the condition: if (possible_hit && approx(time_xy, time_yz, 0.5)) || (possible_hit && approx(time_xz, time_yz, 0.5))

Now diverges at element 4:

Element 3 passed: BigInt[0,1,0]
Place: 
 efficient  BigFloat[6.7756978219103365775e-02,7.62239663929128527552e-01,3.71350844092511238316e-02], 
 classical  BigFloat[6.7756978219103356295e-02,7.62239663929128524245e-01,3.7135084409251119339e-02], 
 difference BigFloat[9.47999274567012939485e-18,3.30681662608078852372e-18,4.49266275223680899842e-18]
Speed: 
 efficient  BigFloat[4.801631428705712938e-01,-8.34568452865158919073e-01,2.70071941732032495213e-01], 
 classical  BigFloat[4.80163142870571217581e-01,-8.34568452865158975614e-01,2.70071941732032459813e-01], 
 difference BigFloat[7.62194127257309617107e-17,5.65411432951190562335e-17,3.53992009316517197703e-17]
---------------------------
Diverged at element 4 - increase precision
Classical: BigInt[4,-6,2]; Efficient: BigInt[3,-5,2]

Call WM for help. Classical wins again! Look for step-by-step E procedure

##################

using EfficientLorentz;

x = [1.89717182844582602939e+00,1.90362852285732340833e+00,9.48629721354036554277e-01]; v = [-7.04877071895435892979e-01,-6.15519586395728865533e-01,-3.52539291823404229151e-01]; r = 0.15

Right: 2,4,1. Wrong: 1,4,1. When tested, a different one showed up. Stuck...


####

compare_lorentz3d(x, v, 0.36, 10, 64)


True: 2,4,1. False: 1,4,1 - what E gives.
There may be two conditions out of 1, 2, 3 that are true! Then it can't decide and may decide on a wrong one (whichever comes first)!
However, collide3d returns false on a right one and a result on a false one.
Need to plot step-by-step points of trajectory in WM to see where it goes wrong.


###############

Let's start with this one:
x = [0.532282, 0.531928, 0.267589]; v = [0.665341, 0.668661, 0.331986];

After two steps (after which we have a discrepancy):

x = [1.97484775450435845402e-01,2.83989775212701109396e-01,9.97475365105846594393e-02]; v = [3.91849048695213618811e-01,8.97636760917618726412e-01,2.01748775674059307268e-01]

possible_hit: false. advance to 0.826701, 1.72538, 0.423708. WM: it is on the trajectory.

possible_hit: true (z's coincide, but it is a wrong place). x_new: false. advance to 1.13375888039167151253e+00, 3.58067543555783089821e+00, 8.40695684709138548222e-01. WM: it is NOT on the trajectory!!! This is what is wrong.




x = [0.532282, 0.531928, 0.267589]; v = [0.0174497, 0.000304586, 0.999848]; r = 0.3

1 and 2 passed, 3 diverged.
x = [1.07956912902745839362e+01,4.71932460899421546274e-02,5.97785452222911003251e+02]; v = [-9.91425164663099117376e-01,-1.26681591839447120493e-01,-3.20611472310415919094e-02]; r = 0.3

Diverged at element 3 - increase precision
Classical: BigInt[10,0,598]; Efficient: BigInt[-13,-3,597]

WM: E is right. But C is also right. Did E miss a valid ball?


x = [0.532282, 0.531928, 0.267589]; v = [-0.83142, -0.393939, 0.391857]; r = 0.35
diverge at element 1: BigInt[1,1,0]; Efficient: BigInt[-7,-3,4]

WM: E is right, C is wrong. Seems like C goes backwards again. Fixed.


x = [1.12572305500350674872e+00,-1.70728533206424794712e+00,-1.44954601913314947928e-01]; v = [7.73314394646670227732e-01,-4.20129722929722670938e-01,-4.74842987674082045945e-01]; r = 0.35

Classical: BigInt[4,-3,-2]; Efficient: BigInt[6,-4,-3]

Both correct, but E missed a ball.
Found out reason: 2r+0.1 is too much advanced (0.8) for this radius, so it flew by the valid ball. Fixed.

Now found another discrepancy:

x = [2.2000297927544893278e+01,9.06653611895305306572e-01,4.09964134096038358257e+02]; v = [5.44662959760666846806e-02,-6.69060196931100424123e-01,7.41209737851011116032e-01]; r = 0.1
Classical: BigInt[22,0,411]; Efficient: BigInt[25,-37,452]


Got rid of time measurements. Fixed one issue. Now new issues appeared!

x = [-1.95002088637292207219e+00,2.80928016023846817959e+00,-9.66413828405320322098e-01]; v = [-1.15934820434215499825e-01,-9.92973826741629231015e-01,2.37085810830404100267e-02]
Classical: BigInt[-2,2,-1]; Efficient: BigInt[-2,3,-1]

###################

Reverted to the old version.

Did a big test with various angles and watched where the discrepancy was at small differences:

x = [2.6972892557756099112e+01,9.93450574027347994626e-01,1.20415005011345926933e+01]; v = [7.40249275699539031773e-01,-2.58928867986558333782e-02,6.71833735562259367247e-01]; r = 0.05

Now C cannot proceed because the initial position is in the ball...



