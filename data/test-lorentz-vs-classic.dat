 [0.0,0.445]        
 [0.971899,1.95864] 
 [-3.99055,-4.9509] 
 [-4.96076,-1.03099]
 [-4.03126,-1.03902]


[[0.0,0.445],[0.971899,1.95864],[-3.99055,-4.9509],[-4.96076,-1.03099],[-4.03126,-1.03902]]
[[initial pos],[1.0,2.0],[-4.0,-5.0],[-5.0,-1.0],[-4.0,-1.0]]
[[0.540302,0.841471],[-0.583343,-0.812226],[-0.240258,0.970709],[0.999963,-0.00864383],[0.226566,-0.973996]]

collide(1.0,2.0,0.0,0.445,cos(1),sin(1),0.05) == (0.971899,1.95864,-0.583343,-0.812226) PASS
collide(-4,-5,0.971899,1.95864,-0.583343,-0.812226,0.05) == (-3.99055,-4.9509,-0.240258,0.970709) 
										output: (-3.9564905633532064,-5.024635927477541,0.9966017424861062,-1.7068228298874433) FAIL
collide(-5,-1,-3.99055,-4.9509,-0.240258,0.970709,0.05) == (-4.96076,-1.03099, 0.999963,-0.00864383) 
										output: (-4.960759036726581,-1.0309862356760902,0.9999628559472674,-0.008619042102779306) FAIL_vy
collide(-4,-1,-4.96076,-1.03099,0.999963,-0.00864383,0.05) == (-4.03126,-1.03902,0.226566,-0.973996)
										output: (-4.030580431257879,-1.0395580235108142,0.24353554102692265,-0.9871380491936136) FAIL
										
Function collide() fails compared to classic algorithm

Classic algorithm gives a pretty good answer to the $100 problem #2, but up to the 7th digit

====================================================


# lorentz-gas2.jl: collisions([0, 0.445], [cos(1), sin(1)], 0.1, 25)

Places: [0.0,0.445],[0.9448796725624946,1.9165629009182235],[-0.9716764156856661,-0.904094971082905],[-0.9897690501215699,-0.09947526157083009],[-0.09242759468983634,-4.961827500214797],[-2.9328562238489915,-6.925893904945792],[0.9010808071201877,-0.014662649146948481]

Circles: [1,2],[-1,-1],[-1,0],[0,-5],[-3,-7],[1,0]

Speeds: [0.5403023058681398,0.8414709848078965],[-0.5620109566725988,-0.8271297870225387],[-0.022480262386806116,0.9997472869695718],[0.18148419443581376,-0.9833938616698721],[-0.8225151657457678,-0.5687431776454224],[0.48509792526653095,0.8744598349278867],[-0.7179057218268957,0.6961403411440853]

Times: [0,1.7487981492958713,5.158973814900654,5.963796913696985,10.908257549629113,14.361602542464304,22.265031584884287]

x = 0; y = 0.445; vx = cos(1); vy = sin(1); r = 0.1
collisions(x, y, vx, vy, r)

collisions(0, 0.445, cos(1), sin(1), 0.1, 10)


=====================================================

problem in efficient_algorithm(): gives wrong answer

example:
x1 = 0
y1 = 0.8523674178538906
vx = -0.5687431776454224
vy = -0.8225151657457678
r = 0.1

first_collision(x1, y1, vx, vy, abs(r/vx)) gives (0, 0), which is incorrect: should be (-2, -2)
first_collision(x1, y1-0.03, vx, vy, abs(r/vx)) gives the correct answer

The problem is caused by the fact that in this case, 1 - b < delta (the same case will be if b < delta). It will hit the ball next to it in one direction and will not in the other.

fixed

=====================================================

problem in EfficientLorentz: after ~10 steps, there is an error for collide() again

x, y, vx, vy = -25.9220385027411,24.062625912729082,0.967026401228994,-0.2546761459699459


