Appendix: Pseudocode for the classical algorithm

Here we present the pseudocode for the classical algorithm for the 2D and 3D periodic Lorentz gas. The 2D version is made of the functions crossing(x, v, n, m) and collisions_classical(x, v, r, tmax).

The function crossing(x, v, n, m) outputs the new position in square [-0.5, 0.5)^2 and updates the position of the new square in case there is no collision in the current cell. First we initialize an empty array of times to each boundary, then take the minimum positive time value. The variable "number" determines the exiting side of the square positioned in the xy-coordinates with the x-axis being horizontal and y-axis vertical (1 - left, 2 - right, 3 - bottom, 4 - top). Then, using this time value, we calculate the new position and the displacement. Then, depending on the exiting side, we increment or decrement the corresponding integer coordinate of the cell and return the new coordinates, displacement, and the integer coordinates (n, m) of the new cell.

function crossing(x, v, n, m)
    Initialize empty scalar array: array_times

	for i = 1:2
		for j = 1:2
			push the value of ((-1)^j*0.5 - x[i])/v[i] into array_times
		end	for
	end for
	
	minpos = Inf
	number = 0
	for i = 1:length(array_times)
		if array_times[i] < minpos && array_times[i] > 0
			minpos = array_times[i]
			number = i
		end	if			
	end for
	
	t = array_times[number]
	x1 = x + v*t
	d = norm(v*t)	
	
	if number == 2
		n += 1
		return [-0.5, x1[2]], d, n, m
	elseif number == 4
		m += 1
		return [x1[1], -0.5], d, n, m
	elseif number == 1
		n -= 1
		return [0.5, x1[2]], d, n, m
	elseif number == 3
		m -= 1
		return [x1[1], 0.5], d, n, m
	elseif error("Don't know which wall was hit; this should not occur.")
	end if
end function

The function collisions_classical(x, v, r, tmax) calculates the trajectory of a particle in a periodic 2D Lorentz gas. We initialize arrays for the coordinates of each collision (places), integer coordinates of each circle that experiences a collision (circles) and velocities at each step (velocities). We push the initial position, initial velocity and initial time (0) into the corresponding arrays. Then we calculate the initial unit square where the initial position is and decrement the initial position by the position of the square so that the position would be counted with respect to the centre of the unit square. We also make sure that the initial position cannot be inside of a circle. While the time is less than the maximum allocated time tmax for the calculation of the trajectory, we check the condition (3) for the collision within the unit cell.

If the collision takes place, using the formulas from Section 2, we determine the coordinates of the collision, time to the collision and the new velocity after the collision. Then we push those values into the corresponding arrays (notice that we need to push the value of the coordinates with respect to the origin, not to the centre of the circle, therefore, we increment it back). After the collision, we determine the exiting parameters using the previously defined function crossing(x1, v1, n, m). The velocity will take on the new value v1 and the time will be incremented by the displacement divided by the speed.

If the collision does not take place (the condition (3) is not satisfied), the particle continues moving with the same velocity and eventually exits the unit square. Using the function crossing(x1, v1, n, m), we determine the exiting parameters and the new unit cell, and increment the time.

function collisions_classical(x, v, r, tmax)
    Initialize empty vector arrays: places, circles, velocities
    Initialize empty scalar array: times
	
    push x into places, push v into velocities, push 0 into times

	n = ifloor(x[1] + 0.5)
	m = ifloor(x[2] + 0.5)
	x -= [n, m]
	
	if norm(x) < r
		error("The initial position cannot be inside an obstacle")
	end if

	t = 0
	while t <= tmax
		vcrossx = abs(crossz(v, x))
		vr = norm(v)*r
		discr = vr^2 - vcrossx^2
		
		if vcrossx < vr && (-dot(v, x) - sqrt(discr)) >= 0
			t1 = (-dot(v, x) - sqrt(discr))/norm(v)^2
			
			N0 = x + v*t1
			N = N0/norm(N0)
			
		    v1 = v - 2dot(v, N)*N
			x1 = N0
			t += t1
			
			push x1 + [n, m] to places
			push [n, m] to circles
			push v1 to velocities
			push t to times
			
			x, d, n, m = crossing(x1, v1, n, m)
			v = v1
			t += d/norm(v)
			
		else # If it misses the ball
			v1 = v
			x1 = x

			x, d, n, m = crossing(x1, v1, n, m)

			v = v1
			t += d/norm(v)
		end if
	end while
	return places, circles, velocities, times
end function


Modifications for the 3D version of the classical algorithm

In the 3D version of the function crossing (crossing3d(x, v, n, m, l)), there will be 3D vectors for x and v and also three integer values of the centre of the obstacle (n, m, l). The variable i would run from 1 to 3 as the number of dimensions increases to 3. Also, there would be two more possible outcomes as in 3D the exit may be made through the two sides of the unit cube z = 1/2 and z = -1/2. In the right-hand xyz-coordinates, the variable "number" will have the value "5" if the exit is made through the "back" side of the cube (z = -1/2) and the value "6" if the exit is made through the "front" side (z = 1/2). The lines of code corresponding to these two additional outcomes will be as follows:

    elseif number == 5
		l -= 1
		return [x1[1], x1[2], 0.5], d, n, m, l
	elseif number == 6
		l += 1
		return [x1[1], x1[2], -0.5], d, n, m, l
		
The only difference between the 3D version of the function calculating the trajectory (collisions3d_classical(x, v, r, tmax)) is the third added dimension: the coordinates and velocities are now 3D and there is the variable l = ifloor(x0[3] + 0.5) which will show up in all the instances of the integer coordinates of the obstacle (n, m, l), including the output of the function crossing3d(x, v, n, m, l).


